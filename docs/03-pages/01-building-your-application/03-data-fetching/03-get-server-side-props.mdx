---
title: getServerSideProps
description: `getServerSideProps`를 사용하여 각 요청에 대한 데이터를 가져옵니다.
---

페이지 내에서 `getServerSideProps`(서버-사이드 렌더링) 함수를 내보내면, Next.js는 `getServerSideProps` 의 반환 데이터를 사용하여 매 요청마다 해당 페이지를 사전 렌더링(pre-render) 합니다.

```tsx filename="pages/index.tsx" switcher
import type { InferGetServerSidePropsType, GetServerSideProps } from 'next'

type Repo = {
  name: string
  stargazers_count: number
}

export const getServerSideProps: GetServerSideProps<{
  repo: Repo
}> = async () => {
  const res = await fetch('https://api.github.com/repos/vercel/next.js')
  const repo = await res.json()
  return { props: { repo } }
}

export default function Page({
  repo,
}: InferGetServerSidePropsType<typeof getServerSideProps>) {
  return repo.stargazers_count
}
```

```jsx filename="pages/index.js" switcher
export const getServerSideProps = async () => {
  const res = await fetch('https://api.github.com/repos/vercel/next.js')
  const repo = await res.json()
  return { props: { repo } }
}

export default function Page({ repo }) {
  return repo.stargazers_count
}
```

> 렌더링 유형과 관계없이 모든 `props`는 페이지 컴포넌트로 전달되며 클라이언트 측 초기 HTML에서 보여집니다. 이는 페이지가 올바르게 [hydrated](https://react.dev/reference/react-dom/hydrate)되도록 하기 위함입니다. `props`에 클라이언트에서 사용하면 안되는 민감한 정보를 전달하지 않도록 주의해야 합니다.

## getServerSideProps가 실행되는 시점

`getServerSideProps`은 오직 서버-사이드에서만 실행되고 브라우저에서 절대 실행되지 않습니다. 만약 페이지 내에서 `getServerSideProps`를 사용할 경우:

- 페이지를 직접 요청하면 `getServerSideProps`는 요청 시점에 실행되고, 해당 페이지는 반환된 props와 함께 사전 렌더링(pre-render) 됩니다.
- [`next/link`](/docs/pages/api-reference/components/link) 혹은 [`next/router`](/docs/pages/api-reference/functions/use-router)를 사용해서 클라이언트 측 페이지 전환을 통해 페이지를 요청하면, Next.js는 `getServerSideProps`를 실행하는 API요청을 서버로 보냅니다.

`getServerSideProps`는 페이지를 렌더링하는데 필요한 JSON을 반환합니다. 이 모든 작업은 Next.js에 의해 자동으로 처리됩니다. 따라서 `getServerSideProps`가 정의되어 있다면 추가적인 작업을 수행할 필요가 없습니다.

[next-code-elimination tool](https://next-code-elimination.vercel.app/)를 사용하면 Next.js가 클라이언트 측 번들에서 제거하는 내용을 확인할 수 있습니다.

`getServerSideProps`는 오직 **페이지**에서만 내보낼 수 있습니다. page가 아닌 파일에서는 내보낼 수 없습니다.

`getServerSideProps`는 독립적인 함수로 내보내야 합니다 - 페이지 컴포넌트의 속성으로 `getServerSideProps`를 추가할 경우 동작하지 않습니다.

[`getServerSideProps` API 레퍼런스](/docs/pages/api-reference/functions/get-server-side-props)는 `getServerSideProps`와 함께 사용할 수 있는 모든 매개변수와 props에 대해 설명합니다.

## getServerSideProps를 사용해야 하는 경우

요청 시 데이터를 가져오는 페이지 렌더링을 할 때 `getServerSideProps`를 사용해야 합니다. 이는 데이터 특성 또는 요청의 속성 (`authorization` 헤더 혹은 지리적 위치(geo location))이 이유가 될 수 있습니다. `getServerSideProps`를 사용하는 페이지는 요청시 서버 측에서 렌더링되며 [캐시-제어 헤더가 구성되어 있을 경우](/docs/pages/building-your-application/deploying/production-checklist#caching)에만 캐시됩니다.

요청 중에 데이터 렌더링할 필요가 없는 경우, [클라이언트 측](#fetching-data-on-the-client-side)에서 데이터를 가져오거나 [`getStaticProps`](/docs/pages/building-your-application/data-fetching/get-static-props)를 고려해야합니다.

### getServerSideProps 또는 API 라우트

`getServerSideProps`에서 서버로부터 데이터를 가져오기 위해 [API 라우트](/docs/pages/building-your-application/routing/api-routes)를 사용하려는 유혹이 있을 수 있습니다. 이는 불필요하고 비효율적인 접근 방식입니다. 왜냐하면 `getServerSideProps`와 API 라우트 둘 다 서버에서 실행되므로 추가 요청이 발생하기 때문입니다.

다음 예를 들어보겠습니다. CMS에서 데이터를 가져오기 위해 API 라우트를 사용하고, 이 API 라우트를 `getServerSideProps`에서 직접 호출합니다. 이렇게 하면 성능이 저하되는 추가적인 호출이 발생합니다. 대신, API 라우트 내부에서 사용되는 로직을 `getServerSideProps`에서 직접 가져오는 것이 좋습니다. 이는 `getServerSideProps` 내부에서 CMS, 데이터베이스 또는 다른 API를 직접 호출하는 것을 의미합니다.

### getServerSideProps를 Edge API 라우트와 함께 사용하는 경우

`getServerSideProps`는 [Serverless 및 Edge Runtimes](/docs/pages/building-your-application/rendering/edge-and-nodejs-runtimes)과 함께 사용할 수 있으며 양쪽에서 모두 props를 설정할 수 있습니다. 하지만, 현재 Edge 런타임에서는 응답 객체에 접근할 수 없습니다. 즉, - 예를 들어 - `getServerSideProps`에서 쿠키를 추가할 수 없습니다. 응답 객체에 접근하려면, 기본적으로 사용되는 **Node.js 런타임을 계속 사용해야 합니다.**

`config`를 수정하여 각 페이지마다 명시적으로 런타임을 설정할 수 있습니다. 예시 코드:

```jsx filename="pages/index.js"
export const config = {
  runtime: 'nodejs', // or "edge"
}

export const getServerSideProps = async () => {}
```

## 클라이언트 측에서 데이터 가져오기

만약 페이지에 자주 업데이트되는 데이터가 포함되어 있고 데이터를 사전 렌더링(pre-render) 할 필요가 없다면, 헤당 데이터를 [클라이언트 측](/docs/pages/building-your-application/data-fetching/client-side)에서 가져올 수 있습니다. 아래는 사용자 별 데이터 예시입니다.

- 먼저, 데이터가 없는 상태에서 즉시 페이지를 표시합니다. 페이지의 일부는 정적 생성(Static Generation)을 사용하여 사전 렌더링(pre-render)할 수 있습니다. 누락된 데이터는 로딩 상태로 표시할 수 있습니다.
- 그 후에, 클라이언트 측에서 데이터를 가져와 준비가 되면 해당 데이터를 표시합니다.

이 접근 방식은 사용자 대시보드 페이지와 같은 경우에 잘 적용해 볼 수 있습니다. 대시보드는 비공개이고 사용자 별 페이지이므로 SEO가 관련이 없고 해당 페이지는 사전 렌더링(pre-render)할 필요가 없습니다. 데이터가 자주 없데이트 되기 때문에, 요청 시간에 데이터를 가져와야 합니다.

## getServerSideProps를 사용하여 요청 시 데이터 가져오기

다음 예시는 요청 시 데이터를 가져오고 결과를 사전 렌더링(pre-render)하는 방법을 보여 줍니다.

```jsx
function Page({ data }) {
  // 데이터 렌더링...
}

// 이 함수는 매 요청마다 호출됩니다
export async function getServerSideProps() {
  // 외부 API에서 데이터 가져오기
  const res = await fetch(`https://.../data`)
  const data = await res.json()

  // props를 통해 데이터를 페이지로 전달
  return { props: { data } }
}

export default Page
```

## Server-Side Rendering (SSR)을 사용한 캐싱

`getServerSideProps`안에서 캐시 헤더(`Cache-Control`)를 사용하여 동적 응답을 캐시할 수 있습니다. 예를 들면, [`stale-while-revalidate`](https://web.dev/stale-while-revalidate/)를 사용할 수 있습니다.

```jsx
// 이 값은 10초 동안 새로운 값(fresh)으로 간주됩니다. (s-maxage=10)
// 다음 10초 내에 동일한 요청이 반복되면, 이전의
// 캐시된 값은 여전히 새로운 값으로 간주됩니다. 동일한 요청이 59초 이내에 반복된다면,
// 캐시된 값은 오래되었지만(stale) 렌더링은 여전히 유지되고 있을 것입니다.(stale-while-revalidate=59).
//
// 백그라운드에서, 캐시를 새로운 값으로 채우기 위해 재검증(revalidation) 요청이 수행됩니다.
// 페이지를 새로고침하면, 새로운 값이 표시됩니다.

export async function getServerSideProps({ req, res }) {
  res.setHeader(
    'Cache-Control',
    'public, s-maxage=10, stale-while-revalidate=59'
  )

  return {
    props: {},
  }
}
```

자세한 내용은 [캐싱](/docs/pages/building-your-application/deploying/production-checklist#caching)을 참조하세요.

## getServerSideProps가 오류 페이지를 렌더링하는 경우

`getServerSideProps` 함수 내에서 오류가 발생하면, `pages/500.js` 파일을 표시합니다. [500 page](/docs/pages/building-your-application/routing/custom-error#500-page)에 대한 문서를 확인하여 해당 페이지를 생성하는 방법에 대해 자세히 알아보세요.
개발 중에는 해당 파일이 사용되지 않고 개발용 오버레이(dev overlay)가 대신 표시됩니다.
